# 과제 3

### 필수 스펙

- 드래그 앤 드롭(D&D) 기능 개발
  - [x] 캘린더의 일정을 마우스로 끌어 다른 날짜나 시간으로 옮기는 기능을 구현합니다.
- 날짜 클릭으로 일정 생성 기능 개발
  - [x] 캘린더의 비어있는 날짜 셀을 클릭하면, 해당 날짜가 자동으로 폼에 채워지도록 하세요.

## 기본 과제

필수 스펙 개발과 E2E, 시각적 회귀 테스트를 모두 작성해주세요.

### 기본과제 제출

- 아래 작성된 E2E 테스트 작성은 필수입니다. 추가로 작성하고 싶다면 작성해주세요.
- 여기서 말하는 전반은 Create, Read, Update, Delete 모두에 해당합니다.

1. [x] 기본 일정 관리 워크플로우 전반을 검증하세요.
2. [x] 반복 일정 관리 워크플로우 전반을 검증하세요.
3. [x] 일정 겹침 처리 방식에 대해 검증하세요.
4. [x] 알림 시스템 관련 노출 조건에 대해 검증하세요.
5. [x] 검색 및 필터링 전반에 대해 검증하세요.

- 아래 시각적 회귀 테스트는 필수 입니다. 추가로 작성하고 싶다면 작성해주세요.

1. [x] 타입에 따른 캘린더 뷰 렌더링
2. [x] 일정 상태별 시각적 표현
3. [x] 다이얼로그 및 모달
4. [x] 폼 컨트롤 상태
5. [x] 각 셀 텍스트 길이에 따른 처리

[chromatic 링크](https://www.chromatic.com/build?appId=690c8ad91e698f36ae316771&number=14)
[storybook 링크](https://690c8ad91e698f36ae316771-berhmwvtwy.chromatic.com/?path=/docs/components-draggableevent--docs&globals=viewport.width:1024)

```
♨️
이 과정에서 컴포넌트 리팩토링이 필요할 수 있습니다!
여유가 있다면 컴포넌트를 아름답게 분리하는 고민을 해주시면 좋지만,
당장은 적절한 스토리를 작성하는데 더 집중해주세요.
적절한 추상화, 응집도를 높이고 결합도를 낮추는
우아한 설계는 이후 주차때 좀 더 집중해봐요.
```

```
- 물론, AI를 활용해도 좋습니다.
- 기존에 작성한 테스트는 깨지지 않도록 해주세요.
  - 이 과정에서 테스트가 분리될 수도 작성법이 수정될 수도 있습니다.
  - 정말 불필요한 케이스가 아니면, 테스트 케이스를 삭제하는건 최소화 해주세요.
  - 추가로 필요한 테스트가 생길 수 있지만, 작성은 자유롭게 선택해서 진행해주세요.
```

## 심화 과제

테스트 전략 작성해보기의 내용을 참고해서 지금까지 작성했던 프로젝트에 대해 테스트 전략을 구상해보세요.

### 심화 과제 제출

- [x] 내가 생각한 최적의 테스트 전략은 무엇인지, 그리고 그 이유를 작성해주세요.

1차적으로 ❗️이 프로젝트의 특성을 파악하고 그에 맞는 전략을 수립할 줄 아는가?❗️가 이번 과제의 목적이라고 생각합니다.
그렇기에 기존에 작성되어있는 단위 테스트랑 통합 테스트가 있지만,
그건 차치하고 프로젝트의 특성과 추후 유지보수를 생각했을 때 비중과 순서를 어떻게 할건지와 이유에 대해서 스스로 사고해보는 게 중요하다고 생각합니다.

저는 캘린더 프로젝트는 핵심 기능 간의 유기적인 연결성과 사용자 흐름의 완결성이 중요하다고 판단했습니다.
따라서 단순히 함수 단위의 로직 검증보다, **실제 사용자 경험(UX)에 가까운** 환경에서의 테스트가 핵심이라고 생각했습니다.

이미 단위 테스트가 일정 수준 구축되어 있었기에, 그 위에 다음과 같은 단계별 전략을 세웠습니다.
✅ 통합테스트 => E2E 테스트 => 시각적 회귀 테스트
- 통합 테스트
핵심 비즈니스 로직이 서로 올바르게 연결되는지 검증합니다.
예를 들어 일정 생성 시 데이터가 올바르게 반영되고, 수정 또는 삭제 시에도 동일한 데이터 일관성이 유지되는지를 확인합니다.

- E2E 테스트
**실제 사용자 시나리오 기반**으로 CRUD 전 과정을 점검합니다.
이를 통해 단위 테스트에서 검증하기 어려운, 화면 간 이동이나 사용자 입력 흐름의 오류를 잡을 수 있습니다.

- 시각적 회귀 테스트
마지막으로 시각적 회귀 테스트를 통해 UI의 시각적 일관성을 유지합니다.
시각적 회귀 테스트의 주 목적은 기능 개발과 리팩토링이 반복되면서 발생할 수 있는 UI 깨짐, 요소 위치 오류, 색상 불일치 등을 자동으로 탐지하기 위함입니다.
이를 통해 프론트엔드 품질을 한 단계 끌어올릴 수 있습니다.

위 전략은 **테스트의 신뢰도(E2E/시각적)**와 실행 효율(통합) 사이의 균형을 잡는 것을 목표로 했습니다!
각 테스트가 상호 보완적으로 작동하도록 설계함으로써, 장기적으로 유지보수가 용이한 구조를 생각했습니다!

---

- [x] 팀원들이 합의한 최적의 테스트 전략은 무엇인지, 그리고 그 이유를 작성해주세요.

🔗 [5팀 피그잼](https://www.figma.com/board/SwcN2Sgc2ksMtjCcPzCImn/%ED%95%AD%ED%95%B4?node-id=0-1&p=f&t=eadiHwDiLtUAaJWq-0)
<img width="762" height="632" alt="image" src="https://github.com/user-attachments/assets/0150a5ee-6493-4417-bfc7-28034e939d69" />

위 피그잼에 팀원들과 두차례 모여서 각자 생각해온 테스트 전략에 대해 발표하고 서로 의견을 나누며 논의하는 시간을 가졌습니다.

처음 도출한 결론은 현재 단위/통합 테스트에는 꽤나 많은 개발이 진행되어있고 이에 대한 검증 또한 충분히 되어있는 상태라고 판단하여
✅ 시각적 회귀 => E2E => 부족한 통합테스트 커버
로 진행하기로 했습니다.

하지만 이후 실제 과제를 진행하면서 이 전략이 프로젝트 특성과 맞지 않는다는 점을 깨달았고
✅ 통합 테스트 중심 => E2E로 검증 가능한 부분만 E2E 테스트로 진행
으로 전략을 변경하게 되었습니다.

이렇게 전략을 변경하게 된 결정적인 이유는 UI가 동적으로 자주 변경되는 프로젝트가 아니기에
**시각적 회귀는 캘린더 프로젝트에 필요한 테스트일지**에 대한 의문이 들었고, 기존에 제공된 테스트 스펙으로도 충분히 검증이 가능하다고 판단했습니다.

위와 같은 결론에 따라 아래의 전략을 새롭게 세웠습니다.
- 기존 단위 및 통합 테스트가 이미 존재하고 있었기 때문에 **추가적인 기능 확장**을 중심으로 통합 테스트를 강화하기로 했습니다.
- 이후 실제 사용자 워크플로우 전반을 점검하는 E2E 테스트를 진행합니다.

---

- [x] 그 전략에 맞춰 추가한 테스트는 무엇인지 나타내주세요.
```typescript
describe('날짜 클릭', () => {
  it('일정 추가 시 캘린더에서 날짜 셀을 클릭하면 해당 날짜에 일정이 생성된다.', async () => {});
  it('일정 수정 시 캘린더에서 날짜 셀을 클릭하면 해당 날짜로 일정이 수정된다.', async () => {});
});

describe('드래그 앤 드롭 (로직 검증)', () => {
  beforeEach(() => {});

  describe('handleDragStart 로직 검증', () => {
    it('dragstart 이벤트 발생 시 dataTransfer에 eventId가 올바르게 설정된다', async () => {});
  });

  describe('handleDragEnd 로직 검증', () => {
    it('같은 날짜로 드래그하면 업데이트가 트리거되지 않는다', async () => {});
    it('반복 일정을 드래그하면 다이얼로그 상태가 설정된다', async () => {});
    it('충돌하는 일정이 있으면 다이얼로그 상태가 설정된다', async () => {});
  });
});

```
해당 테스트는 날짜 셀 클릭 기능 검증과
외부 라이브러리없이 구현한 드래그 앤 드롭(DnD) 코드의 안정성을 보장하기 위해 추가되었습니다!
기능 자체가 UI 상의 동작과 밀접히 연관되어 있기 때문에, 단순 E2E 테스트로는 충분히 검증하기 어려운 **핵심 로직** 단위의 동작을 세밀하게 확인하는 것이 목적이었습니다.

✅ DnD 검증 포인트
(1) handleDragStart 로직 검증
(2) handleDragEnd 로직 검증
- 같은 날짜로 드래그 시
- 반복 일정 드래그 시
- 충돌 일정 존재 시

---
## 챕터1에 대한 회고
항해부터 테스트코드, 코어타임 등 모든 것이 처음이었던 시기였고 낯선 환경에 적응해 가는 동안 테스트 코드가 첫 주제였다는 점이 특히 도전적이었습니다.

처음부터 초면인 테스트코드가 주제로 나와서 1주차 발제를 들으며 막막했던 감정이 아직도 생생합니다ㅜㅜ

하지만 챕터1을 진행하면서 얻은 점은 단순히 테스트 코드에 대한 것에 그치지 않고, 기능의 의도를 추론하고 스스로 사고하는 힘을 키우는 방법에 대해서도 배운 것 같습니다!
제가 퍼블리셔이기에 상대적으로 FE 지식이 얕았던만큼 오히려 모르는 것을 집요하게 파고드는 태도를 갖게 된 것 같습니다.
이미 알고 있거나 익숙해진 내용은 다시 들여다보지 않게 되지만 모르는 것을 대할 때 언제든 깊이있게 탐구해볼 기회가 주어지기 때문입니다.

그 깨달음이 가장 컸던 순간은 2주차 AI agent를 활용한 TDD 설계를 하던 시기였습니다.
하물며 테스트코드도 익숙지 않은 상황에서, 사용 경험이 적었던 AI를 활용하여 AI agent를 생성하라는 과제를 듣고 하룻밤을 고민하고 고뇌의 시간을 가졌습니다.

그 과정 속에서 기록의 중요성과 직접 사고하며 구조를 파악하는 능력이 왜 개발자에게 핵심 역량인지 분명히 알게 되었습니다.
비록 완벽한 에이전트를 만들진 못했지만, 과제의 의도를 정확히 읽고 그에 맞게 접근했다는 점에서 큰 성장을 느꼈습니다.

아래는 개인적인 챕터1의 주차별 리뷰입니다.

[1주차_Chapter 1-1. 프론트엔드 테스트 코드 익숙해지기](https://chaeng03.tistory.com/entry/%ED%95%AD%ED%95%B499-WIL-1%EC%A3%BC%EC%B0%A8Chapter-1-1-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0)
- 테스트 코드와의 소개팅
- Easy -> Medium -> Hard로의 점진적 단계 수행을 통한 테스트 코드 감각 익히기
- import 흔적을 단서로 작성 방식 추론

[2주차_Chapter 1-2. AI와 테스트를 활용한 안정적인 기능 개발](https://chaeng03.tistory.com/entry/%ED%95%AD%ED%95%B499-WIL-2%EC%A3%BC%EC%B0%A8Chapter-1-2-AI%EC%99%80-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C)
- 지시를 그저 수행하는 개발자에서 사고하는 개발자로 진화
- AI에게는 짧고 깊은 컨텍스트로 물어보기
- 각 AI의 장/단점 정리 및 활용 전략 수립

---

## 과제 셀프회고

<!-- 과제에 대한 회고를 작성해주세요 -->

### 기술적 성장
이번 과제를 통해 테스트 자동화 도구의 전체 흐름을 이해할 수 있었습니다!
특히 Playwright를 사용하며 test-fixtures, beforeEach, locator 등의 개념을 실습을 통해 이해하며 테스트 코드가 단순히 오류를 찾는 도구가 아니라 **기능 의도를 문서화하는 수단**이라는 점을 실감했습니다.

추가로 시각적 회귀 테스트를 적용하면서 Storybook + Chromatic 환경 설정 및 픽셀 단위 비교 검증 과정을 처음으로 경험했습니다!
이전에는 단순히 UI를 눈으로 확인하던 방식에서 벗어나, 자동화된 품질 보증의 필요성을 이해할 수 있게 되었습니다.

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

### 코드 품질
#### 만족스러운 구현
1. 테스트 환경과 실제 환경 분리
- TEST_ENV=e2e 환경변수로 e2e.json과 realEvents.json을 분리
- E2E 테스트 실행 시 자동으로 e2e.json 사용
- 실제 데이터에 영향 없이 테스트 가능

2. 테스트 간 독립성 보장
- Playwright fixtures 패턴으로 각 테스트 전 자동 데이터 리셋
- /api/reset-e2e-data 엔드포인트로 초기 상태로 복원
- 테스트 간 상호 영향 최소화

3. 자동화된 테스트 환경 구성
- playwright.config.ts에서 TEST_ENV=e2e로 서버 자동 실행
- fixtures에서 자동 리셋과 페이지 이동 처리

4. 안정성 고려 <= 이 부분은 AI가 도와줬습니다!
- queueFileOperation로 race condition 방지
- try-catch로 리셋 실패 시 경고 처리(테스트 중단 없이 진행)
- e2e 모드에서만 리셋 API 동작하도록 보호

#### 개선이 필요한 점 = 하단 리뷰 받고 싶은 내용
- 테스트 작성 전략: 점진적 vs 병렬적 접근의 의미와 적용 기준을 명확히 하고 싶습니다!
- 테스트 레이어 구분: 통합/E2E의 역할 구분과 중복 허용 기준을 정리하고 싶습니다!
<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 학습 효과 분석
가장 큰 배움은 **“테스트는 실행이 아니라 사고의 과정”**이라는 점이었습니다!
테스트를 작성하는 과정에서 기능의 흐름을 더 깊이 이해하게 되었고,
AI를 활용한 테스트 케이스 설계를 통해 사고력 중심의 개발 습관을 기를 수 있었습니다.

또한 시각적 회귀 테스트는 실무에서도 활용 가능성이 높다고 느꼈습니다.
배포 전 UI 안정성을 빠르게 확인할 수 있어 퍼블리셔이자 프론트엔드 개발자로서 강력한 무기가 될 것 같습니다.

---

### 🧐 팀원과 생각을 나눈 주제 - MSW의 필요성에 대하여
화요일 오프 코치님의 멘토링을 들으면서 모킹과 MSW의 역할에 대해 근본적인 의문이 생겼습니다.
<img width="635" height="564" alt="image" src="https://github.com/user-attachments/assets/6a1aca68-add4-4cb5-bd9d-2debc1565f1d" />
처음에는 E2E 테스트에서도 당연히 MSW를 사용하면 되지 않을까? 하는 막연한 생각을 갖고 있었는데
E2E용 json을 생성하여 1주차 때의 realEvent.json과 같이 가짜 DB를 만들어줌으로써 실제 서버 통신과 유사하게 데이터를 주고받으며 테스트할 수 있다는 개념을 이해하게 되었습니다.

즉, 단순히 요청을 흉내내는 것이 아니라
프론트엔드 단에서 데이터가 실제로 잘 주입되고 표시되는지까지 검증할 수 있다는 점이 핵심이었습니다!

이 깨달음을 통해 “테스트는 단지 기능이 잘 돌아가는가의 문제를 넘어 데이터의 흐름과 통신의 신뢰성까지 확인해야 한다”는 인사이트를 얻게 되었습니다.

이후 팀원인 재윤님과 함께 “그렇다면 MSW는 왜 필요한가?”에 대해 깊게 이야기하게 되었고 재윤님이 도와주신 덕에 결론은 명확했습니다.
<img width="1586" height="1624" alt="Group 66" src="https://github.com/user-attachments/assets/a7793635-2aa9-4cef-ae29-5b1ad622c210" />
MSW는 API 개발 전에, 프론트엔드가 실제 서버 없이도 UI와 로직을 안정적으로 테스트하기 위해 필요한 도구다.

이 대화를 통해 단순히 툴을 사용하는 수준을 넘어 “언제, 왜, 어떤 테스트 상황에서 해당 도구를 사용해야 하는가”를 고민할 수 있는 사고력을 키우고 싶어졌습니다.

결국 MSW는 테스트 과정의 필수 요소라기보다
상황에 맞는 테스트 환경을 구성하기 위한 옵션 중 하나라는 점을 명확히 인식하게 되었습니다!

---
<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

### 과제 피드백
- 좋았던 점: 팀 단위로 논의하며 사고의 깊이를 확장할 수 있던 점이 인상 깊었습니다.
- 어려웠던 점: 시각적 회귀 테스트 도입 과정에서 환경 설정과 테스트 실행 기준을 세우는 데 어려움이 있었습니다.
<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

## 리뷰 받고 싶은 내용
#### 1. 테스트 작성 전략: 점진적 vs 병렬적 접근
멘토링에서 “각 테스트를 점진적으로 하지 않고 병렬적으로 해도 된다”는 말씀을 들었는데,
아직 두 접근의 차이와 실제 적용 기준이 완전히 와닿지 않습니다.

제가 이해한 바는 아래와 같습니다!
- 점진적: 기능 A → 테스트 A → 기능 B → 테스트 B (단계적으로 작성)
- 병렬적: 기능 A, B, C 구현 후 테스트 A, B, C를 한 번에 작성

❗️질문:
- 병렬 접근의 장단점은 무엇인가요?
- 프로젝트 성격(예: 캘린더처럼 기능 간 연결성이 강한 경우)에 따라 어떤 기준으로 접근 방식을 선택하면 좋을까요?


#### 2. 통합 테스트와 E2E 테스트의 역할 구분
현재 프로젝트에서는 다음처럼 나누어 작성했습니다.
- 통합 테스트: 내부 로직과 컴포넌트 간 상호작용 검증
→ 예: handleDragStart, handleDragEnd
- E2E 테스트: 실제 사용자 시나리오 검증
→ 예: “캘린더 셀 클릭 → 일정 이동 → UI 반영 확인”

❗️질문:
- 같은 기능을 두 레이어(통합/E2E)에서 검증해도 괜찮을까요, 아니면 중복을 피하는 게 좋을까요?
- 두 테스트 레이어의 목적과 범위를 구분할 때 어떤 기준이 가장 명확할까요?

#### 3. 쿼링 방식에 대한 고민
E2E 테스트를 작성할 때 처음에는 first, nth 등 인덱스 기반으로 요소를 선택했는데,
이 방식은 정확히 원하는 일정을 특정하기 어렵다는 한계를 느꼈습니다.

그래서 이후에는 filter, locator 등을 사용해
데이터 속성(data-date, data-id)이나 텍스트 기반 쿼링으로 전환했습니다.

❗️질문:
이런 방식(filter, locator 등 의미 기반 쿼링)을 사용하는 것이 테스트의 안정성과 유지보수성 측면에서 적절한 접근일까요?
혹은 더 권장되는 쿼링 전략(예: role, label, data-testid 기반 선택자)이 있을까요?

아래 링크는 이번 주차 과제를 진행하며 정리한 글입니다! 😊
[3주차_프로젝트에 적합한 테스트 전략 수립](https://chaeng03.tistory.com/entry/%ED%95%AD%ED%95%B499-3%EC%A3%BC%EC%B0%A8%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%A0%81%ED%95%A9%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A0%84%EB%9E%B5-%EC%88%98%EB%A6%BD)

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 요청의 예시)
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 요청의 예시)
- 현재 함수와 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수를 더 명확하게 이름 지을 수 있는 방법에 대해 조언해주실 수 있나요?
- 현재 파일 단위로 코드가 분리되어 있지만, 모듈화나 계층화가 부족한 것 같습니다. 어떤 기준으로 클래스를 분리하거나 모듈화를 진행하면 유지보수에 도움이 될까요?
- MVC 패턴을 따르려고 했는데, 제가 구현한 구조가 MVC 원칙에 맞게 잘 구성되었는지 검토해주시고, 보완할 부분을 제안해주실 수 있을까요?
- 컴포넌트 간의 의존성이 높아져서 테스트하기 어려운 상황입니다. 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?
-->
